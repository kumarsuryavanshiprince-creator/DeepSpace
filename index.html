<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DeepSpace</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>  
    /* Full-screen black background, no scrollbars, hide default cursor */
    html, body {
      margin: 0;
      overflow: hidden;
      background: #000000;
      cursor: none; /* We'll draw our own custom cursor */
      font-family: Arial, sans-serif;
    }

    canvas { display: block; } /* Makes canvas fill the screen properly */

    /* Custom glowing cursor that follows the mouse */
    #cursor {
      position: absolute;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: radial-gradient(circle, #00000069, #b91d929c 70%);
      box-shadow: 0 0 25px rgba(0, 80, 252, 0.5);
      pointer-events: none; /* Doesn't block clicks */
      transform: translate(-50%, -50%);
    }
  </style>
</head>

<body>
  <!-- Our custom cursor dot -->
  <div id="cursor"></div>

  <!-- Background music (loops forever) -->
  <audio id="bgMusic" loop preload="auto">
    <source src="distorted_memories.mp3" type="audio/mpeg">
  </audio>

  <!-- Sound effect for supernova explosions -->
  <audio id="explosionSound" preload="auto">
    <source src="explosion.mp3" type="audio/mpeg">
  </audio>

  <!-- Button to start music (some browsers block autoplay) -->
  <button id="startSound" style="
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 10;
  ">
    ðŸ”Š Start Music
  </button>

  <script>
    // Create a full-screen canvas for drawing everything
    const canvas = document.createElement("canvas");
    document.body.appendChild(canvas);
    const ctx = canvas.getContext("2d");

    // Make canvas always fill the window, even on resize
    function resize() {
      canvas.width = innerWidth;
      canvas.height = innerHeight;
    }
    resize();
    addEventListener("resize", resize);

    // Track mouse position for interactive effects
    let mx = innerWidth / 2, my = innerHeight / 2;
    const cursor = document.getElementById("cursor");

    addEventListener("mousemove", e => {
      mx = e.clientX;
      my = e.clientY;
      cursor.style.left = mx + "px";
      cursor.style.top = my + "px";
    });

    // Background music setup
    const music = document.getElementById("bgMusic");
    music.volume = 1.0; // Full volume

    // Click button to start music (required on many browsers)
    document.getElementById("startSound").addEventListener("click", () => {
      music.play().catch(err => console.log("Error playing music:", err));
    });

    // Explosion sound for supernovas
    const explosionSound = document.getElementById("explosionSound");
    explosionSound.volume = 0.9;

    // Slow rotation of the whole galaxy field
    let galaxyAngle = 0;

    /* ===== Supernovas (click to create big colorful explosions) ===== */
    const supernovas = [];

    class Supernova {
      constructor(x, y) {
        this.x = x; this.y = y;
        this.radius = 1;
        this.maxRadius = Math.random() * 300 + 200; // Random final size
        this.life = 1; // 1 = full brightness, 0 = gone
        this.hue = Math.random() * 60 + 300; // Purple/pink tones
      }
      update() {
        this.radius += 8; // Expand quickly
        this.life = 1 - (this.radius / this.maxRadius);
        return this.life > 0; // Return false when faded out
      }
      draw() {
        const alpha = this.life;
        ctx.save();
        ctx.globalAlpha = alpha * 0.6;
        ctx.globalCompositeOperation = "screen"; // Brighten colors

        // Outer glow
        const outerGrad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 1.5);
        outerGrad.addColorStop(0, `hsla(${this.hue}, 100%, 80%, ${alpha})`);
        outerGrad.addColorStop(0.5, `hsla(${this.hue + 30}, 90%, 70%, ${alpha * 0.5})`);
        outerGrad.addColorStop(1, "transparent");
        ctx.fillStyle = outerGrad;
        ctx.fillRect(this.x - this.radius * 1.5, this.y - this.radius * 1.5, this.radius * 3, this.radius * 3);

        // Bright core
        ctx.globalAlpha = alpha;
        const innerGrad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 0.6);
        innerGrad.addColorStop(0, "white");
        innerGrad.addColorStop(0.4, `hsl(${this.hue}, 100%, 80%)`);
        innerGrad.addColorStop(1, "transparent");
        ctx.fillStyle = innerGrad;
        ctx.fillRect(this.x - this.radius * 0.6, this.y - this.radius * 0.6, this.radius * 1.2, this.radius * 1.2);

        ctx.restore();
      }
    }

    // Click anywhere to make a supernova + play explosion sound
    canvas.addEventListener("click", (e) => {
      supernovas.push(new Supernova(e.clientX, e.clientY));
      explosionSound.currentTime = 0;
      explosionSound.play().catch(() => {});
    });

    /* ===== Stars (twinkling background stars in a galaxy spiral) ===== */
    const stars = [];
    const STAR_COUNT = 1800;

    class Star {
      constructor() { this.reset(); }
      reset() {
        this.radius = Math.random() * Math.max(canvas.width, canvas.height) / 2; // Distance from center
        this.angle = Math.random() * Math.PI * 2;
        this.depth = Math.random(); // Used for size and parallax
        this.size = Math.random() * 1.4 + 0.3;
        this.baseAlpha = Math.random() * 0.5 + 0.3;
        this.twinkle = Math.random() * Math.PI * 2; // For twinkling effect
        this.twinkleSpeed = Math.random() * 0.01 + 0.005;
        this.color = Math.random() > 0.9 ? "#cfd8ff" : (Math.random() > 0.95 ? "#e0d8ff" : "#e6ecff");
      }
      update(gx, gy) {
        this.angle += 0.00005 * (0.2 + this.depth); // Slow orbit
        this.twinkle += this.twinkleSpeed;
        this.x = gx + Math.cos(this.angle + galaxyAngle) * this.radius;
        this.y = gy + Math.sin(this.angle + galaxyAngle) * this.radius;

        // Stars get gently pulled toward the mouse cursor
        const dx = mx - this.x;
        const dy = my - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 1100) {
          const pull = (1100 - dist) / 1100 * this.depth * 0.8;
          this.x -= dx * pull;
          this.y -= dy * pull;
        }
      }
      draw() {
        const alpha = this.baseAlpha * (0.9 + 0.9 * Math.sin(this.twinkle));
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * (0.1 + this.depth), 0, 6.28);
        ctx.fill();
      }
    }

    // Create all the stars
    for (let i = 0; i < STAR_COUNT; i++) stars.push(new Star());

    /* ===== Planets (glowing orbs orbiting the center) ===== */
    const planets = [];
    const PLANET_COUNT = 12;

    class Planet {
      constructor() { this.reset(); }
      reset() {
        this.radius = Math.random() * Math.max(canvas.width, canvas.height) * 0.45 + 80;
        this.angle = Math.random() * Math.PI * 2;
        this.depth = Math.random() * 0.7 + 0.3;
        this.size = Math.random() < 0.2 ? Math.random() * 12 + 10 : Math.random() * 5 + 3; // Some big, most small
        this.hue = Math.random() * 360;
        this.baseAlpha = Math.random() * 0.4 + 0.7;
        this.twinkle = Math.random() * Math.PI * 2;
        this.twinkleSpeed = Math.random() * 0.007 + 0.003;
      }
      update(gx, gy) {
        this.angle += 0.00004 * (0.3 + this.depth);
        this.twinkle += this.twinkleSpeed;
        this.x = gx + Math.cos(this.angle + galaxyAngle * 0.9) * this.radius;
        this.y = gy + Math.sin(this.angle + galaxyAngle * 0.9) * this.radius;

        // Pulled gently toward mouse
        const dx = mx - this.x;
        const dy = my - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 1200) {
          const pull = (1200 - dist) / 1200 * 1.2 * this.depth;
          this.x -= dx * pull * 0.9;
          this.y -= dy * pull * 0.9;
        }
      }
      draw() {
        const alpha = this.baseAlpha * (0.85 + 0.75 * Math.sin(this.twinkle));
        const color = `hsl(${this.hue}, 85%, 65%)`;

        // Outer glow
        ctx.globalAlpha = alpha * 0.35;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * (2 + this.depth * 2), 0, Math.PI * 2);
        ctx.fill();

        // Planet with highlight
        ctx.globalAlpha = alpha;
        const gradient = ctx.createRadialGradient(
          this.x - this.size * 0.4, this.y - this.size * 0.4, 0,
          this.x, this.y, this.size * (0.8 + this.depth)
        );
        gradient.addColorStop(0, "white");
        gradient.addColorStop(0.4, color);
        gradient.addColorStop(0.9, "#000000");
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * (0.8 + this.depth), 0, Math.PI * 2);
        ctx.fill();
      }
    }

    for (let i = 0; i < PLANET_COUNT; i++) planets.push(new Planet());

    /* ===== Nebulae (slowly drifting colorful clouds) ===== */
    const nebulae = [];
    class Nebula {
      constructor() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.radius = Math.random() * 400 + 300;
        const colorThemes = [
          {hue:270+Math.random()*60},
          {hue:180+Math.random()*60},
          {hue:300+Math.random()*60},
          {hue:200+Math.random()*40},
          {hue:320+Math.random()*40}
        ];
        this.hue = colorThemes[Math.floor(Math.random()*colorThemes.length)].hue;
        this.opacity = Math.random() * 0.08 + 0.03;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotSpeed = (Math.random() - 0.5) * 0.00015;
        this.driftX = (Math.random() - 0.5) * 0.04;
        this.driftY = (Math.random() - 0.5) * 0.04;
      }
      update() {
        this.x += this.driftX;
        this.y += this.driftY;
        this.rotation += this.rotSpeed;
        // Wrap around screen edges
        if (this.x < -this.radius) this.x += canvas.width + this.radius * 2;
        if (this.x > canvas.width + this.radius) this.x -= canvas.width + this.radius * 2;
        if (this.y < -this.radius) this.y += canvas.height + this.radius * 2;
        if (this.y > canvas.height + this.radius) this.y -= canvas.height + this.radius * 2;
      }
      draw() {
        this.update(); // Move and rotate
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.radius);
        grad.addColorStop(0, `hsla(${this.hue}, 90%, 65%, ${this.opacity * 2})`);
        grad.addColorStop(0.4, `hsla(${this.hue + 20}, 80%, 50%, ${this.opacity * 0.8})`);
        grad.addColorStop(0.8, `hsla(${this.hue + 40}, 70%, 40%, ${this.opacity * 0.4})`);
        grad.addColorStop(1, "transparent");
        ctx.globalCompositeOperation = "screen";
        ctx.fillStyle = grad;
        ctx.fillRect(-this.radius * 1.4, -this.radius * 1.4, this.radius * 2.8, this.radius * 2.8);
        ctx.restore();
      }
    }
    for (let i = 0; i < 8; i++) nebulae.push(new Nebula());

    /* ===== Central Spiral Galaxy ===== */
    const galaxy = {
      radius: Math.min(innerWidth, innerHeight) * 0.45,
      arms: 4,
      armTight: 2.5,
      hue: 220,
      rotation: 0,
      rotSpeed: 0.0003
    };

    function drawGalaxy(cx, cy) {
      galaxy.rotation += galaxy.rotSpeed;
      galaxy.radius = Math.min(canvas.width, canvas.height) * 0.45; // Keep it responsive

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(galaxy.rotation);

      // Bright core glow
      const coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, galaxy.radius * 0.2);
      coreGrad.addColorStop(0, "white");
      coreGrad.addColorStop(0.5, "hsl(50, 100%, 80%)");
      coreGrad.addColorStop(1, "transparent");
      ctx.globalCompositeOperation = "screen";
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = coreGrad;
      ctx.fillRect(-galaxy.radius * 0.3, -galaxy.radius * 0.3, galaxy.radius * 0.6, galaxy.radius * 0.6);

      // Spiral arms made of many tiny particles
      const particlesPerArm = 600;
      for (let a = 0; a < galaxy.arms; a++) {
        const armAngle = (a / galaxy.arms) * Math.PI * 2;
        for (let i = 0; i < particlesPerArm; i++) {
          const t = i / particlesPerArm;
          const dist = galaxy.radius * t;
          const twist = dist * galaxy.armTight;
          const angle = armAngle + twist + Math.random() * 0.4;

          const px = Math.cos(angle) * dist;
          const py = Math.sin(angle) * dist * 0.5; // Slightly flattened

          const size = (1 - t) * (Math.random() * 2 + 1);
          const alpha = (1 - t) * 0.6 * (0.7 + Math.random() * 0.3);
          const hueShift = Math.random() * 60;

          ctx.globalAlpha = alpha;
          ctx.fillStyle = `hsl(${galaxy.hue + hueShift}, 90%, ${70 + Math.random() * 20}%)`;
          ctx.fillRect(px - size/2, py - size/2, size, size);
        }
      }

      // Soft outer halo
      const haloGrad = ctx.createRadialGradient(0, 0, galaxy.radius * 0.3, 0, 0, galaxy.radius);
      haloGrad.addColorStop(0, "transparent");
      haloGrad.addColorStop(0.7, `hsla(${galaxy.hue + 30}, 80%, 60%, 0.15)`);
      haloGrad.addColorStop(1, "transparent");
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = haloGrad;
      ctx.fillRect(-galaxy.radius, -galaxy.radius, galaxy.radius * 2, galaxy.radius * 2);

      ctx.restore();
    }

    /* ===== Meteors (shooting stars that appear randomly) ===== */
    const meteors = [];
    const MAX_METEORS = 6;

    class Meteor {
      constructor() { this.reset(); }
      reset() {
        // Start from random edge of screen
        const side = Math.floor(Math.random() * 4);
        if (side === 0) { this.x = Math.random() * canvas.width; this.y = -50; }
        else if (side === 1) { this.x = canvas.width + 50; this.y = Math.random() * canvas.height; }
        else if (side === 2) { this.x = Math.random() * canvas.width; this.y = canvas.height + 50; }
        else { this.x = -50; this.y = Math.random() * canvas.height; }

        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 7 + 5;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;

        this.length = Math.random() * 100 + 70;
        this.life = 1;
        this.isColorful = Math.random() < 0.1; // Rare colorful meteors
        this.tailHue = Math.random() * 60 + 240;
      }
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.018;
        if (this.life <= 0 || this.x < -200 || this.x > canvas.width + 200 || this.y < -200 || this.y > canvas.height + 200) {
          this.reset(); // Respawn when off-screen or faded
        }
      }
      draw() {
        const alpha = Math.max(0, this.life);
        ctx.save();
        ctx.globalAlpha = alpha;

        const grad = ctx.createLinearGradient(this.x, this.y, this.x - this.vx * this.length / 10, this.y - this.vy * this.length / 10);
        if (this.isColorful) {
          grad.addColorStop(0, `hsla(${this.tailHue}, 90%, 70%, ${alpha})`);
        } else {
          grad.addColorStop(0, `rgba(255,255,255,${alpha})`);
        }
        grad.addColorStop(1, "transparent");
        ctx.strokeStyle = grad;
        ctx.lineWidth = 9;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x - this.vx * this.length / 10, this.y - this.vy * this.length / 10);
        ctx.stroke();

        // Bright white core line
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
      }
    }

    // Slowly add new meteors over time
    setInterval(() => {
      if (meteors.length < MAX_METEORS && Math.random() < 0.35) {
        meteors.push(new Meteor());
      }
    }, 1000);

    /* ===== Floating Letters (type letters to make them appear and drift) ===== */
    const letters = [];
    class Letter {
      constructor(char) {
        this.char = char;
        this.x = canvas.width / 2 + (Math.random() - 0.5) * 200;
        this.y = canvas.height / 2 + (Math.random() - 0.5) * 200;
        this.vx = (Math.random() - 0.5) * 0.3;
        this.vy = (Math.random() - 0.5) * 0.3;
        this.size = Math.random() * 30 + 50;
        this.alpha = 1;
        this.rot = Math.random() * 6.28;
        this.rotV = (Math.random() - 0.5) * 0.01;
      }
      update() {
        // Gentle pull away from mouse (repulsion)
        const dx = mx - this.x;
        const dy = my - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 200) {
          this.vx -= dx / dist * 0.1;
          this.vy -= dy / dist * 0.1;
        }
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= 0.99; // Friction
        this.vy *= 0.99;
        this.rot += this.rotV;
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rot);
        ctx.font = `bold ${this.size}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#cfd8ff";
        ctx.globalAlpha = this.alpha;
        ctx.shadowBlur = 20;
        ctx.shadowColor = "#8aa0ff";
        ctx.fillText(this.char, 0, 0);
        ctx.restore();
      }
    }

    // Press any letter key to spawn a floating letter
    addEventListener("keydown", e => {
      if (e.key.length === 1 && /[a-z]/i.test(e.key)) {
        letters.push(new Letter(e.key.toUpperCase()));
      }
    });

    /* ===== Main Animation Loop ===== */
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      galaxyAngle += 0.0009; // Slow overall rotation

      // Draw everything in the right order (background first)
      drawGalaxy(cx, cy);           // 1. Central galaxy
      nebulae.forEach(n => n.draw()); // 2. Nebulae clouds
      stars.forEach(s => { s.update(cx, cy); s.draw(); }); // 3. Stars
      planets.forEach(p => { p.update(cx, cy); p.draw(); }); // 4. Planets

      ctx.globalCompositeOperation = "screen";
      // 5. Supernova explosions (additive brightening)
      for (let i = supernovas.length - 1; i >= 0; i--) {
        if (!supernovas[i].update()) {
          supernovas.splice(i, 1);
        } else {
          supernovas[i].draw();
        }
      }

      ctx.globalCompositeOperation = "source-over";
      meteors.forEach(m => { m.update(); m.draw(); }); // 6. Meteors
      letters.forEach(l => { l.update(); l.draw(); }); // 7. Floating letters

      requestAnimationFrame(animate);
    }
    animate(); // Start the show!
  </script>

  <!-- Optional: Live reload for development (ignores in production) -->
  <script>
    if ('WebSocket' in window) {
      (function () {
        function refreshCSS() {
          var sheets = [].slice.call(document.getElementsByTagName("link"));
          var head = document.getElementsByTagName("head")[0];
          for (var i = 0; i < sheets.length; ++i) {
            var elem = sheets[i];
            var parent = elem.parentElement || head;
            parent.removeChild(elem);
            var rel = elem.rel;
            if (elem.href && typeof rel != "string" || rel.length == 0 || rel.toLowerCase() == "stylesheet") {
              var url = elem.href.replace(/(&|\?)_cacheOverride=\d+/, '');
              elem.href = url + (url.indexOf('?') >= 0 ? '&' : '?') + '_cacheOverride=' + (new Date().valueOf());
            }
            parent.appendChild(elem);
          }
        }
        var protocol = window.location.protocol === 'http:' ? 'ws://' : 'wss://';
        var address = protocol + window.location.host + window.location.pathname + '/ws';
        var socket = new WebSocket(address);
        socket.onmessage = function (msg) {
          if (msg.data == 'reload') window.location.reload();
          else if (msg.data == 'refreshcss') refreshCSS();
        };
      })();
    }
  </script>
</body>
</html>